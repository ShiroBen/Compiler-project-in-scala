package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        case Variable(name) => GetLocal(locals(name))
        
        case IntLiteral(value) => Const(value)

        case BooleanLiteral(value) => if (value) Const(1) else Const(0) 

        case StringLiteral(value) => mkString(value)

        case UnitLiteral() => Const(0)

        case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add

        case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub

        case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul

        case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div

        case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem

        case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s

        case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s

        case AmyAnd(lhs, rhs) => cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End

        case AmyOr(lhs, rhs) => cgExpr(lhs) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(rhs) <:> End

        case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq 
          // for strings and ADTs, since we only care reference equality, so we will only compare their positions in memory

        case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)

        case Not(e) => cgExpr(e) <:> If_i32 <:> Const(0) <:> Else <:> Const(1) <:> End

        case Neg(e) => Const(0) <:> cgExpr(e) <:> Sub

        case AmyCall(qname, args) => // function call or ADT call
          table.getConstructor(qname) match {
            case Some(conSig) =>
              val oldMemBound = lh.getFreshLocal()

              val body: List[Code] = (args.map(arg => cgExpr(arg)).zip(1 to args.size)).map(argCode =>
                GetLocal(oldMemBound) <:> Const(4 * argCode._2) <:> Add <:> argCode._1 <:> Store)

              // 1. save the old memory boundary

              GetGlobal(Utils.memoryBoundary) <:> SetLocal(oldMemBound) <:> 
              // 2. Increment the current memory boundary by the size of the allocated ADT value
              GetGlobal(Utils.memoryBoundary) <:> Const(4*(args.size+1)) <:> Add <:> SetGlobal(Utils.memoryBoundary) <:>
              // 3. Store the constructor index to address b
              Const(conSig.index) <:> GetLocal(oldMemBound) <:> Store <:>
              // 4. For each field of the constructor, generate code for it and store it in memory in the correct offset from b
              body <:>
              // 5. Push b to the stack (base address of the ADT)
              GetLocal(oldMemBound)



            case None => // function call
              args.map(arg => cgExpr(arg)) <:> Call(fullName(table.getFunction(qname).get.owner, qname))
          }

        case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)

        case Let(df, value, body) => 
          val newDef = lh.getFreshLocal()
          cgExpr(value) <:> SetLocal(newDef) <:> cgExpr(body)(locals+(df.name -> newDef), lh)

        case Ite(cond, thn, els) => cgExpr(cond) <:> If_i32 <:> cgExpr(thn) <:> Else <:> cgExpr(els) <:> End

        case Match(scrut, cases) =>
          // helper function
          def matchAndBind(inputCode: Code, pat: Pattern): (Code, Map[Identifier, Int]) = { // want to generate a bool and leave it on stack
            pat match {
              case WildcardPattern() =>
                (inputCode <:> Drop <:> Const(1), locals)

              case IdPattern(name) =>
                val newVar = lh.getFreshLocal()
                (inputCode <:> SetLocal(newVar) <:> Const(1), locals+(name->newVar))

              case LiteralPattern(lit) =>
                (inputCode <:> cgExpr(lit) <:> Eq, locals)

              case CaseClassPattern(constr, args) =>
                val patConstrIndex = table.getConstructor(constr).get.index
                val newVar = lh.getFreshLocal()
                val argsAndNewLocalsCodes = args.zipWithIndex.map(pair =>
                  matchAndBind(GetLocal(patConstrIndex) <:> Utils.adtField(pair._2) <:> Load, pair._1))
                val patBody: Code = {
                  if (args.isEmpty) Const(1)
                  else if (args.lengthCompare(1) == 0) argsAndNewLocalsCodes.map(_._1)
                  else argsAndNewLocalsCodes.map(_._1) <:> args.tail.map(arg => And)
                }
                val newlocals = argsAndNewLocalsCodes.map(_._2).foldLeft(Map[Identifier, Int]())((m1: Map[Identifier, Int], m2: Map[Identifier, Int]) => m1 ++ m2)


                (inputCode <:> SetLocal(newVar) <:> GetLocal(newVar) <:> Load <:> Const(patConstrIndex) <:> Eq <:> If_i32 <:> patBody <:> Else <:> Const(0) <:> End
                ,locals ++ newlocals)

            }
          }

          // main logic of body: eval scrut, store into memory, for each case, judge and eval
          // final code
          val newLocal = lh.getFreshLocal()
          val patCodeWithMap: List[(Code, Map[Identifier, Int])] = cases.map {case MatchCase(pat, e) => matchAndBind(GetLocal(newLocal), pat)}
          val body: List[Code] = cases.zip(patCodeWithMap).map {case (MatchCase(pat, e), (code, newlocals)) => code <:> If_i32 <:> cgExpr(e)(newlocals, lh) <:> Else}
          cgExpr(scrut) <:> SetLocal(newLocal) <:> body <:> mkString("Match error!") <:> Call("Std_printString") <:> Unreachable <:> cases.map(c=>End)

        case Error(msg) => cgExpr(msg) <:> Call("Std_printString") <:> Unreachable


      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
